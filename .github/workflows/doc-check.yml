name: Documentation & Architecture Checks

on:
  push:
  pull_request:

jobs:
  checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute changed files
        shell: bash
        run: |
          set -euo pipefail

          # Keep changed file paths in UTF-8 to avoid escaped octal output on CJK paths.
          git config core.quotepath false

          safe_diff_for_push() {
            local before_sha="$1"
            local after_sha="$2"
            local default_branch="${{ github.event.repository.default_branch }}"
            if [ -z "${default_branch}" ]; then
              default_branch="main"
            fi

            if [ "${before_sha}" = "0000000000000000000000000000000000000000" ]; then
              echo "IS_ROOT=1" >> diff_meta.env
              git diff --name-only --root "${after_sha}" > changed_files.txt
              git diff --name-status --root "${after_sha}" > changed_name_status.txt
              return 0
            fi

            if git cat-file -e "${before_sha}^{commit}" 2>/dev/null; then
              echo "IS_ROOT=0" >> diff_meta.env
              git diff --name-only "${before_sha}" "${after_sha}" > changed_files.txt
              git diff --name-status "${before_sha}" "${after_sha}" > changed_name_status.txt
              return 0
            fi

            echo "IS_ROOT=0" >> diff_meta.env
            echo "warning: before SHA 不可达（${before_sha}），改用 merge-base 回退计算 diff。"
            git fetch --no-tags origin "${default_branch}" --depth=1 >/dev/null 2>&1 || true
            default_ref="origin/${default_branch}"
            if ! git show-ref --verify --quiet "refs/remotes/${default_ref}"; then
              default_ref="HEAD~1"
            fi
            base_commit="$(git merge-base "${default_ref}" "${after_sha}" 2>/dev/null || true)"
            if [ -n "${base_commit}" ]; then
              git diff --name-only "${base_commit}" "${after_sha}" > changed_files.txt
              git diff --name-status "${base_commit}" "${after_sha}" > changed_name_status.txt
            else
              git diff-tree --no-commit-id --name-only -r "${after_sha}" > changed_files.txt
              git diff-tree --no-commit-id --name-status -r "${after_sha}" > changed_name_status.txt
            fi
          }

          EVENT_NAME="${{ github.event_name }}"

          : > changed_files.txt
          : > changed_name_status.txt
          : > diff_meta.env

          if [ "${EVENT_NAME}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"

            if [ -z "${BASE_SHA}" ] || [ -z "${HEAD_SHA}" ]; then
              echo "pull_request 事件但 base/head sha 为空，无法计算 diff。" >&2
              exit 1
            fi

            DIFF_RANGE="${BASE_SHA}...${HEAD_SHA}"

            echo "DIFF_MODE=pull_request" >> diff_meta.env
            echo "DIFF_RANGE=${DIFF_RANGE}" >> diff_meta.env
            echo "BASE_SHA=${BASE_SHA}" >> diff_meta.env
            echo "HEAD_SHA=${HEAD_SHA}" >> diff_meta.env

            git diff --name-only "${DIFF_RANGE}" > changed_files.txt
            git diff --name-status "${DIFF_RANGE}" > changed_name_status.txt
          else
            BEFORE_SHA="${{ github.event.before }}"
            AFTER_SHA="${{ github.sha }}"

            echo "DIFF_MODE=push" >> diff_meta.env
            echo "BEFORE_SHA=${BEFORE_SHA}" >> diff_meta.env
            echo "AFTER_SHA=${AFTER_SHA}" >> diff_meta.env

            safe_diff_for_push "${BEFORE_SHA}" "${AFTER_SHA}"
          fi

          echo "Changed files:"
          cat changed_files.txt || true
          echo "Changed name-status:"
          cat changed_name_status.txt || true
          echo "Diff meta:"
          cat diff_meta.env || true

      - name: Enforce commit subject convention
        shell: bash
        run: |
          set -euo pipefail

          safe_rev_list_for_push() {
            local before_sha="$1"
            local after_sha="$2"
            local default_branch="${{ github.event.repository.default_branch }}"
            if [ -z "${default_branch}" ]; then
              default_branch="main"
            fi

            if [ "${before_sha}" = "0000000000000000000000000000000000000000" ]; then
              git rev-list --no-merges -n 1 "${after_sha}" > commit_shas.txt
              return 0
            fi

            if git cat-file -e "${before_sha}^{commit}" 2>/dev/null; then
              git rev-list --no-merges "${before_sha}..${after_sha}" > commit_shas.txt
              return 0
            fi

            echo "warning: before SHA 不可达（${before_sha}），改用 merge-base 回退计算 commit 范围。"
            git fetch --no-tags origin "${default_branch}" --depth=1 >/dev/null 2>&1 || true
            default_ref="origin/${default_branch}"
            if ! git show-ref --verify --quiet "refs/remotes/${default_ref}"; then
              default_ref="HEAD~1"
            fi
            base_commit="$(git merge-base "${default_ref}" "${after_sha}" 2>/dev/null || true)"
            if [ -n "${base_commit}" ]; then
              git rev-list --no-merges "${base_commit}..${after_sha}" > commit_shas.txt
            else
              git rev-list --no-merges -n 1 "${after_sha}" > commit_shas.txt
            fi
          }

          EVENT_NAME="${{ github.event_name }}"
          : > commit_shas.txt
          : > commit_subject_failures.txt

          if [ "${EVENT_NAME}" = "pull_request" ]; then
            BASE_REF="${{ github.base_ref }}"
            git rev-list --no-merges "origin/${BASE_REF}..HEAD" > commit_shas.txt
          else
            BEFORE_SHA="${{ github.event.before }}"
            AFTER_SHA="${{ github.sha }}"
            safe_rev_list_for_push "${BEFORE_SHA}" "${AFTER_SHA}"
          fi

          if [ ! -s commit_shas.txt ]; then
            echo "无新增非 merge commit，跳过提交标题校验。"
            exit 0
          fi

          subject_regex='^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([[:alnum:]./_-]+\))?!?: .{1,72}$'
          while IFS= read -r sha; do
            [ -n "${sha}" ] || continue
            subject="$(git show -s --format=%s "${sha}" | tr -d '\r')"

            if echo "${subject}" | grep -Eq '^(fixup!|squash!|Revert ")'; then
              continue
            fi

            if ! echo "${subject}" | grep -Eq "${subject_regex}"; then
              echo "${sha}: ${subject}" >> commit_subject_failures.txt
              continue
            fi

            if ! echo "${subject}" | grep -P -q '[\x{4e00}-\x{9fff}]'; then
              echo "${sha}: 提交标题默认应使用中文（可保留必要英文术语） -> ${subject}" >> commit_subject_failures.txt
            fi
          done < commit_shas.txt

          if [ -s commit_subject_failures.txt ]; then
            echo "以下提交标题不符合规范：type(scope): summary"
            echo "允许类型：feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"
            cat commit_subject_failures.txt
            exit 1
          fi

      - name: Enforce and print structured commit details
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -s commit_shas.txt ]; then
            echo "无新增非 merge commit，跳过提交结构化明细校验。"
            exit 0
          fi

          required_headers=(
            "功能:"
            "功能与文件映射:"
            "涉及文件:"
            "主要改动:"
            "为什么改:"
            "验证:"
          )
          headers_regex='^(功能:|功能与文件映射:|涉及文件:|主要改动:|为什么改:|验证:)$'
          : > commit_body_failures.txt

          extract_section() {
            local file="$1"
            local header="$2"
            awk -v header="${header}" -v headers_regex="${headers_regex}" '
              $0 == header {in_section=1; next}
              $0 ~ headers_regex {if (in_section) exit}
              in_section {print}
            ' "${file}"
          }

          clean_section() {
            local file="$1"
            local header="$2"
            extract_section "${file}" "${header}" \
              | sed 's/\r$//' \
              | grep -vE '^[[:space:]]*(<!--.*-->)?[[:space:]]*$' || true
          }

          while IFS= read -r sha; do
            [ -n "${sha}" ] || continue
            subject="$(git show -s --format=%s "${sha}" | tr -d '\r')"
            if echo "${subject}" | grep -Eq '^(fixup!|squash!|Revert ")'; then
              continue
            fi

            body_file="$(mktemp)"
            git show -s --format=%B "${sha}" > "${body_file}"

            for header in "${required_headers[@]}"; do
              if ! grep -Fx "${header}" "${body_file}" >/dev/null; then
                echo "${sha}: 缺少段落 ${header}" >> commit_body_failures.txt
                continue
              fi

              section_content="$(clean_section "${body_file}" "${header}")"
              if [ -z "${section_content}" ]; then
                echo "${sha}: 段落为空 ${header}" >> commit_body_failures.txt
                continue
              fi

              if echo "${section_content}" | grep -Eq '<[^>]+>'; then
                echo "${sha}: 段落包含占位符 ${header}" >> commit_body_failures.txt
              fi
            done

            mapping_block="$(clean_section "${body_file}" "功能与文件映射:")"
            if [ -n "${mapping_block}" ] && ! echo "${mapping_block}" | grep -Eq '^[[:space:]]*-[[:space:]]*[^:]+:[[:space:]]*.+$'; then
              echo "${sha}: 功能与文件映射格式错误（需为 - 功能: 文件列表）" >> commit_body_failures.txt
            fi

            for zh_header in "功能:" "主要改动:" "为什么改:"; do
              zh_content="$(clean_section "${body_file}" "${zh_header}")"
              if [ -n "${zh_content}" ] && ! echo "${zh_content}" | grep -P -q '[\x{4e00}-\x{9fff}]'; then
                echo "${sha}: 段落默认应包含中文描述 ${zh_header}" >> commit_body_failures.txt
              fi
            done

            short_sha="$(git rev-parse --short "${sha}")"
            echo "[commit-detail] -----"
            echo "[commit-detail] 提交: [${short_sha}] ${subject}"
            for header in "功能:" "功能与文件映射:" "涉及文件:" "为什么改:" "验证:"; do
              section_content="$(clean_section "${body_file}" "${header}")"
              if [ -n "${section_content}" ]; then
                echo "[commit-detail] ${header}"
                printf '%s\n' "${section_content}" | sed 's/^/[commit-detail]   /'
              fi
            done
            echo "[commit-detail] 文件清单："
            git show --name-status --format='' "${sha}" | sed 's/^/[commit-detail]   /' || true

            rm -f "${body_file}"
          done < commit_shas.txt

          if [ -s commit_body_failures.txt ]; then
            echo "以下提交不满足结构化提交模板要求："
            cat commit_body_failures.txt
            exit 1
          fi

      - name: Enforce PR template usage
        if: github.event_name == 'pull_request'
        shell: bash
        run: |
          set -euo pipefail

          template=".github/pull_request_template.md"
          if [ ! -f "${template}" ] && [ -f ".github/PULL_REQUEST_TEMPLATE.md" ]; then
            template=".github/PULL_REQUEST_TEMPLATE.md"
          fi

          if [ ! -f "${template}" ]; then
            echo "缺少 PR 模板（.github/pull_request_template.md 或 .github/PULL_REQUEST_TEMPLATE.md）。"
            echo "下一步：补充 .github/pull_request_template.md 或 .github/PULL_REQUEST_TEMPLATE.md。"
            exit 1
          fi

          pr_body_file="pr_body.md"
          printf '%s\n' "${{ github.event.pull_request.body }}" > "${pr_body_file}"

          if ! grep -q '[^[:space:]]' "${pr_body_file}"; then
            echo "PR 描述不能为空，必须按模板填写。"
            echo "下一步：按 .github/pull_request_template.md 完整填写 PR 描述后重试。"
            exit 1
          fi

          required_sections=(
            "## 变更摘要（Summary）"
            "## 变更类型（Type）"
            "## 功能清单（Features）"
            "## 功能与文件映射（Feature-File Mapping）"
            "## 改动原因（Why）"
            "## 主要改动（What Changed）"
            "## 验证（Verification）"
            "## docs / ADR（系统记录）"
            "## 可观测性 / Trace"
            "## 安全（Security）"
            "## 影响与回滚（Impact / Rollback）"
          )

          for section in "${required_sections[@]}"; do
            if ! grep -F "${section}" "${pr_body_file}" >/dev/null; then
              echo "PR 描述缺少模板段落：${section}"
              echo "下一步：补齐缺失段落后重试；模板见 .github/pull_request_template.md。"
              exit 1
            fi
          done

          extract_section() {
            local section_title="$1"
            awk -v section_title="${section_title}" '
              $0 == section_title {in_section=1; next}
              /^## / {if (in_section) exit}
              in_section {print}
            ' "${pr_body_file}"
          }

          filter_meaningful_lines() {
            grep -vE '^[[:space:]]*(<!--.*-->)?[[:space:]]*$' \
              | grep -vE '^[[:space:]]*-[[:space:]]*[^:：]+[：:][[:space:]]*$' \
              | grep -vE '^[[:space:]]*<[[:space:]]*[^>]+>[[:space:]]*$' || true
          }

          require_non_empty_section() {
            local section_title="$1"
            local block
            block="$(extract_section "${section_title}" | filter_meaningful_lines)"
            if [ -z "${block}" ]; then
              echo "PR 模板中的“${section_title}”不能为空。"
              echo "下一步：根据 .github/pull_request_template.md 填写该段落的实际内容。"
              exit 1
            fi
          }

          require_non_empty_section "## 变更摘要（Summary）"
          require_non_empty_section "## 功能清单（Features）"
          require_non_empty_section "## 功能与文件映射（Feature-File Mapping）"
          require_non_empty_section "## 改动原因（Why）"
          require_non_empty_section "## 主要改动（What Changed）"
          require_non_empty_section "## 影响与回滚（Impact / Rollback）"

          mapping_block="$(extract_section "## 功能与文件映射（Feature-File Mapping）" | grep -vE '^[[:space:]]*(<!--.*-->)?[[:space:]]*$' || true)"
          if ! echo "${mapping_block}" | grep -Eq '^[[:space:]]*-[[:space:]]*[^:]+:[[:space:]]*.+$'; then
            echo "PR 模板中的“功能与文件映射”格式错误，要求：- 功能: 文件列表"
            echo "下一步：改为“- 功能: 文件A, 文件B”格式；参考 .github/pull_request_template.md。"
            exit 1
          fi

          if ! grep -Eq '^[[:space:]]*-[[:space:]]\[[xX]\][[:space:]](Feature|Bugfix|Refactor|Docs|Chore)[[:space:]]*$' "${pr_body_file}"; then
            echo "PR 模板中的“变更类型（Type）”至少需要勾选一项。"
            echo "下一步：至少勾选 1 个变更类型复选框（Feature/Bugfix/Refactor/Docs/Chore）。"
            exit 1
          fi

      - name: Print structured PR details
        if: github.event_name == 'pull_request'
        shell: bash
        run: |
          set -euo pipefail

          pr_title="$(printf '%s' "${{ github.event.pull_request.title }}" | tr -d '\r')"
          pr_body_file="pr_body.md"
          printf '%s\n' "${{ github.event.pull_request.body }}" > "${pr_body_file}"

          print_section() {
            local section_title="$1"
            echo "[pr-detail] ${section_title}"
            section_content="$(awk -v section_title="${section_title}" '
              $0 == section_title {in_section=1; next}
              /^## / {if (in_section) exit}
              in_section {print}
            ' "${pr_body_file}" | grep -vE '^[[:space:]]*(<!--.*-->)?[[:space:]]*$' || true)"

            if [ -z "${section_content}" ]; then
              echo "[pr-detail]   (空)"
            else
              printf '%s\n' "${section_content}" | sed 's/^/[pr-detail]   /'
            fi
          }

          echo "[pr-detail] 标题: ${pr_title}"
          print_section "## 变更摘要（Summary）"
          print_section "## 功能清单（Features）"
          print_section "## 功能与文件映射（Feature-File Mapping）"
          print_section "## 改动原因（Why）"
          print_section "## 主要改动（What Changed）"
          print_section "## 验证（Verification）"
          print_section "## docs / ADR（系统记录）"
          print_section "## 可观测性 / Trace"
          print_section "## 安全（Security）"
          print_section "## 影响与回滚（Impact / Rollback）"

          echo "[pr-detail] 文件清单（changed_files.txt）"
          if [ -s changed_files.txt ]; then
            sed 's/^/[pr-detail]   /' changed_files.txt
          else
            echo "[pr-detail]   (无文件变更)"
          fi

      - name: Enforce docs top-level structure and ADR base files
        shell: bash
        run: |
          set -euo pipefail

          required_dirs=(
            "docs/00-术语表"
            "docs/01-产品"
            "docs/02-架构"
            "docs/03-领域模型"
            "docs/04-接口"
            "docs/05-事件"
            "docs/06-数据"
            "docs/07-运行态"
            "docs/08-安全"
            "docs/09-ADR-架构决策"
          )

          for d in "${required_dirs[@]}"; do
            if [ ! -d "$d" ]; then
              echo "缺少固定 docs 顶层目录：$d"
              exit 1
            fi
          done

          required_files=(
            "docs/09-ADR-架构决策/ADR-模板.md"
            "docs/09-ADR-架构决策/ADR-索引.md"
          )

          for f in "${required_files[@]}"; do
            if [ ! -f "$f" ]; then
              echo "缺少 ADR 基础文件：$f"
              exit 1
            fi
          done

          for d in "${required_dirs[@]}"; do
            if ! find "$d" -maxdepth 1 -type f -name "*.md" | grep -q .; then
              echo "顶层目录缺少总览/索引页（至少一个 *.md）：$d"
              exit 1
            fi
          done

      - name: Enforce docs index/navigation integrity
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -x scripts/docs/index-check.sh ]; then
            echo "缺少可执行索引校验脚本：scripts/docs/index-check.sh"
            exit 1
          fi

          scripts/docs/index-check.sh

      - name: Enforce rule docs markdown and Chinese description
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -x scripts/docs/rule-files-check.sh ]; then
            echo "缺少可执行规则文件校验脚本：scripts/docs/rule-files-check.sh"
            exit 1
          fi

          scripts/docs/rule-files-check.sh changed_files.txt

      - name: Enforce git governance sync (hook/workflow/template/docs)
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -x scripts/docs/git-governance-sync-check.sh ]; then
            echo "缺少可执行一致性校验脚本：scripts/docs/git-governance-sync-check.sh"
            exit 1
          fi

          scripts/docs/git-governance-sync-check.sh

      - name: Enforce governance checklist update for git gate changes
        if: github.event_name == 'pull_request'
        shell: bash
        run: |
          set -euo pipefail

          gate_changed=0
          while IFS= read -r f; do
            case "${f}" in
              .githooks/*|\
              .github/workflows/doc-check.yml|\
              .github/workflows/quality-gates.yml|\
              .github/commit_message_template.md|\
              .github/pull_request_template.md|\
              .github/PULL_REQUEST_TEMPLATE.md|\
              scripts/dev/install-git-hooks.sh|\
              scripts/docs/git-governance-sync-check.sh|\
              AGENTS.md|\
              docs/02-架构/工程治理/工程治理与门禁.md|\
              docs/02-架构/工程治理/分支与门禁落地.md)
                gate_changed=1
                break
                ;;
            esac
          done < changed_files.txt

          if [ "${gate_changed}" -eq 0 ]; then
            echo "未检测到 Git 门禁相关实现/规则文件变更，跳过。"
            exit 0
          fi

          if ! grep -Fx "docs/02-架构/工程治理/Git门禁与模板对照清单.md" changed_files.txt >/dev/null; then
            echo "检测到 Git 门禁相关实现/规则文件变更，但未更新唯一信息源文档。"
            echo "下一步：同步更新 docs/02-架构/工程治理/Git门禁与模板对照清单.md（实现位置/文档位置/自动约束）。"
            exit 1
          fi

      - name: Enforce experience docs update for high-risk git governance changes
        shell: bash
        run: |
          set -euo pipefail

          event_name="${{ github.event_name }}"
          high_risk_changed=0
          low_risk_only=0
          touched_experience=0

          while IFS= read -r f; do
            case "${f}" in
              docs/02-架构/工程治理/经验库/*)
                touched_experience=1
                ;;
            esac
            case "${f}" in
              .githooks/*|\
              .github/workflows/doc-check.yml|\
              .github/workflows/quality-gates.yml|\
              .github/commit_message_template.md|\
              .github/pull_request_template.md|\
              .github/PULL_REQUEST_TEMPLATE.md|\
              scripts/dev/install-git-hooks.sh|\
              scripts/docs/git-governance-sync-check.sh)
                high_risk_changed=1
                ;;
              AGENTS.md|\
              docs/02-架构/工程治理/*)
                low_risk_only=1
                ;;
            esac
          done < changed_files.txt

          if [ "${high_risk_changed}" -eq 0 ]; then
            if [ "${low_risk_only}" -eq 1 ] && [ "${touched_experience}" -eq 0 ]; then
              echo "warning: 检测到治理规则文档变更但未更新经验库（低风险场景不阻断）。"
              echo "建议：24 小时内补充 docs/02-架构/工程治理/经验库/ 对应经验文档。"
            else
              echo "未检测到高风险 Git 门禁变更，跳过经验库硬门禁。"
            fi
            exit 0
          fi

          if [ "${touched_experience}" -eq 1 ]; then
            echo "检测到高风险 Git 门禁变更，且已更新经验库文档，校验通过。"
            exit 0
          fi

          if [ "${event_name}" != "pull_request" ]; then
            echo "warning: push 事件检测到高风险 Git 门禁变更但未更新经验库。"
            echo "建议：在 PR 中补充经验库更新，或填写经验库豁免说明与补齐截止日期（<=24h）。"
            exit 0
          fi

          pr_body_file="pr_body.md"
          printf '%s\n' "${{ github.event.pull_request.body }}" > "${pr_body_file}"

          exemption_reason="$(awk -F'经验库豁免说明：[[:space:]]*' '/经验库豁免说明：/ {print $2}' "${pr_body_file}" | tail -n 1 | tr -d '\r')"
          exemption_due="$(awk -F'补齐截止日期（[^）]*）：[[:space:]]*' '/补齐截止日期（/ {print $2}' "${pr_body_file}" | tail -n 1 | tr -d '\r')"

          if [ -z "${exemption_reason}" ] || [ -z "${exemption_due}" ]; then
            echo "检测到高风险 Git 门禁变更，但未更新经验库文档。"
            echo "下一步：更新 docs/02-架构/工程治理/经验库/；或在 PR 填写“经验库豁免说明/补齐截止日期（YYYY-MM-DD，<=T+1日）”。"
            exit 1
          fi

          if ! echo "${exemption_due}" | grep -Eq '^[0-9]{4}-[0-9]{2}-[0-9]{2}$'; then
            echo "经验库豁免补齐截止日期格式错误：${exemption_due}"
            echo "下一步：使用 YYYY-MM-DD，且不晚于 T+1 日（UTC）。"
            exit 1
          fi

          if ! due_epoch="$(date -u -d "${exemption_due}" +%s 2>/dev/null)"; then
            echo "经验库豁免补齐截止日期不可解析：${exemption_due}"
            echo "下一步：使用有效日期（YYYY-MM-DD）。"
            exit 1
          fi

          today_utc="$(date -u +%Y-%m-%d)"
          max_due_utc="$(date -u -d '+1 day' +%Y-%m-%d)"
          if [[ "${exemption_due}" < "${today_utc}" ]] || [[ "${exemption_due}" > "${max_due_utc}" ]]; then
            echo "经验库豁免补齐截止日期超出允许范围（日期口径 T+1 日）：${exemption_due}"
            echo "下一步：将补齐截止日期设置为今天或明天（UTC），或直接补充经验库文档。"
            exit 1
          fi

          echo "检测到高风险 Git 门禁变更，未更新经验库文档，但 PR 已提供有效豁免（日期口径 T+1 日）。"

      - name: Enforce docs update when business code/config/sql changes
        shell: bash
        run: |
          set -euo pipefail

          if grep -E "^(modules|apps|services|src)/.*(\.(java|kt|xml|yml|yaml|sql|properties|json|conf|toml|gradle|kts|js|jsx|ts|tsx|py|go|rs)|/(pom\.xml|build\.gradle(\.kts)?))$" changed_files.txt >/dev/null; then
            if ! grep -E "^(docs/)" changed_files.txt >/dev/null; then
              echo "检测到业务代码/配置/SQL 等变更，但未更新 docs 文档。"
              echo "建议：按契约类型更新 docs/03-领域模型、docs/04-接口、docs/05-事件、docs/06-数据 等。"
              exit 1
            fi
          fi

      - name: Enforce contract-specific docs updates
        shell: bash
        run: |
          set -euo pipefail

          need_domain=0
          need_api=0
          need_event=0
          need_data=0
          need_runtime=0
          need_security=0

          while IFS= read -r f; do
            case "$f" in
              modules/*|apps/*|services/*|src/*)
                case "$f" in
                  */controller/*|*/controllers/*|*/web/*|*/api/*|*/rest/*|*/grpc/*)
                    need_api=1 ;;
                esac

                case "$f" in
                  */event/*|*/events/*|*/mq/*|*/kafka/*|*/rabbit*/*|*/producer/*|*/consumer/*|*/schema/*|*/schemas/*)
                    need_event=1 ;;
                esac

                case "$f" in
                  */entity/*|*/entities/*|*/mapper/*|*/repository/*|*/dao/*|*/dal/*|*/migration/*|*/migrations/*|*.sql)
                    need_data=1 ;;
                esac

                case "$f" in
                  */domain/*|*/workflow/*|*/state/*|*/decision/*|*/rule/*|*/rules/*)
                    need_domain=1 ;;
                esac

                case "$f" in
                  */trace/*|*/runtime/*|*/window/*|*/replay/*|*/observability/*|*/telemetry/*)
                    need_runtime=1 ;;
                esac

                case "$f" in
                  */security/*|*/auth/*|*/permission/*|*/audit/*)
                    need_security=1 ;;
                esac
                ;;
            esac
          done < changed_files.txt

          touched_domain_docs=$(grep -E "^docs/03-领域模型/" changed_files.txt || true)
          touched_api_docs=$(grep -E "^docs/04-接口/" changed_files.txt || true)
          touched_event_docs=$(grep -E "^docs/05-事件/" changed_files.txt || true)
          touched_data_docs=$(grep -E "^docs/06-数据/" changed_files.txt || true)
          touched_runtime_docs=$(grep -E "^docs/07-运行态/" changed_files.txt || true)
          touched_security_docs=$(grep -E "^docs/08-安全/" changed_files.txt || true)

          if [ "$need_domain" -eq 1 ] && [ -z "$touched_domain_docs" ]; then
            echo "检测到领域/流程/状态相关变更，但未更新 docs/03-领域模型/。"
            exit 1
          fi
          if [ "$need_api" -eq 1 ] && [ -z "$touched_api_docs" ]; then
            echo "检测到接口相关变更，但未更新 docs/04-接口/。"
            exit 1
          fi
          if [ "$need_event" -eq 1 ] && [ -z "$touched_event_docs" ]; then
            echo "检测到事件相关变更，但未更新 docs/05-事件/。"
            exit 1
          fi
          if [ "$need_data" -eq 1 ] && [ -z "$touched_data_docs" ]; then
            echo "检测到数据/持久化相关变更，但未更新 docs/06-数据/。"
            exit 1
          fi
          if [ "$need_runtime" -eq 1 ] && [ -z "$touched_runtime_docs" ]; then
            echo "检测到运行态（trace/runtime/window/replay/observability/telemetry）相关变更，但未更新 docs/07-运行态/。"
            exit 1
          fi
          if [ "$need_security" -eq 1 ] && [ -z "$touched_security_docs" ]; then
            echo "检测到安全/权限/审计相关变更，但未更新 docs/08-安全/。"
            exit 1
          fi

      - name: Enforce OpenAPI and event schema placement
        shell: bash
        run: |
          set -euo pipefail

          misplaced_api=$(grep -E "^docs/04-接口/.*\.(ya?ml|json)$" changed_files.txt | grep -vE "^docs/04-接口/(OpenAPI|Examples|示例)/" || true)
          if [ -n "$misplaced_api" ]; then
            echo "检测到 docs/04-接口/ 下的 YAML/JSON 文件未放在允许目录（OpenAPI/Examples/示例）："
            echo "$misplaced_api"
            exit 1
          fi

          misplaced_event=$(grep -E "^docs/05-事件/.*\.(ya?ml|json|avsc|proto)$" changed_files.txt | grep -vE "^docs/05-事件/(Schemas|Examples|示例)/" || true)
          if [ -n "$misplaced_event" ]; then
            echo "检测到 docs/05-事件/ 下的 Schema/示例文件未放在允许目录（Schemas/Examples/示例）："
            echo "$misplaced_event"
            exit 1
          fi

      - name: Enforce ADR/HOTFIX when architecture/security/runtime/compat changes
        shell: bash
        run: |
          set -euo pipefail

          is_hotfix_context=0
          REF_NAME="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME:-}}"
          if echo "${REF_NAME}" | grep -Eiq "(^|/)(hotfix|hf)(/|$|-)"; then
            is_hotfix_context=1
          fi

          adr_required=0
          security_adr_required=0
          runtime_strategy_change=0
          data_risk_change=0
          infra_boundary_change=0

          if grep -E "^docs/02-架构/" changed_files.txt >/dev/null; then adr_required=1; fi
          if grep -E "^docs/08-安全/" changed_files.txt >/dev/null; then adr_required=1; security_adr_required=1; fi
          if grep -E "^docs/05-事件/版本与兼容策略\.md$" changed_files.txt >/dev/null; then adr_required=1; fi
          if grep -E "^docs/05-事件/Schemas/" changed_files.txt >/dev/null; then adr_required=1; fi

          # docs/07 与 docs/06 不做“一改就 ADR”，仅在明显命中运行态策略/迁移兼容风险语义时触发。
          if grep -E "^docs/07-运行态/.*(窗口|window|回放|replay|保留|retention|归档|archive|容量|capacity|性能|performance)" changed_files.txt >/dev/null; then
            runtime_strategy_change=1
            adr_required=1
          fi
          if grep -E "^docs/06-数据/.*(迁移|migration|索引|index|保留|retention|归档|archive|兼容|breaking|回滚|rollback|补偿)" changed_files.txt >/dev/null; then
            data_risk_change=1
            adr_required=1
          fi

          # 仅基础设施/部署类清单变更触发 ADR；普通业务配置与常规依赖升级不直接触发 ADR（仍需 docs 更新）。
          if grep -E "^(infra|infrastructure|deploy|deployment|ops|helm|charts|k8s|kubernetes|terraform)/" changed_files.txt >/dev/null; then
            infra_boundary_change=1
            adr_required=1
          fi
          if grep -E "^(Dockerfile|docker-compose(\.ya?ml)?|compose\.ya?ml)$" changed_files.txt >/dev/null; then
            infra_boundary_change=1
            adr_required=1
          fi
          if grep -E "^(infra|infrastructure|deploy|deployment|ops|helm|charts|k8s|kubernetes|terraform)/.*(ya?ml|json|tf|tfvars|hcl|conf|toml)$" changed_files.txt >/dev/null; then
            infra_boundary_change=1
            adr_required=1
          fi

          added_adr=$(grep -E "^A[[:space:]]+docs/09-ADR-架构决策/ADR-[0-9]{8}-.*\.md$" changed_name_status.txt || true)
          added_hotfix=$(grep -E "^A[[:space:]]+docs/09-ADR-架构决策/HOTFIX-[0-9]{8}-.*\.md$" changed_name_status.txt || true)
          touched_adr_index=$(grep -E "^[AMR][[:space:]]+docs/09-ADR-架构决策/ADR-索引\.md$" changed_name_status.txt || true)

          if [ "$security_adr_required" -eq 1 ] && [ -z "$added_adr" ]; then
            echo "检测到安全文档变更。按 AGENTS.md 要求，安全策略变化必须新增 ADR（HOTFIX 不能替代 ADR）。"
            exit 1
          fi

          if [ "$adr_required" -eq 1 ] && [ -z "$added_adr" ]; then
            if [ "$is_hotfix_context" -eq 1 ] && [ -n "$added_hotfix" ]; then
              echo "hotfix 场景下检测到关键变更，已新增 HOTFIX 记录，允许临时通过。"
            else
              echo "检测到需 ADR 的关键变更（架构/安全/事件兼容与Schema/运行态策略/数据迁移兼容风险/基础设施边界），但未新增 ADR。"
              echo "常规场景必须新增：docs/09-ADR-架构决策/ADR-YYYYMMDD-简短标题.md"
              echo "仅 hotfix 分支场景可使用 HOTFIX-YYYYMMDD-简短标题.md 作为临时记录。"
              exit 1
            fi
          fi

          if [ -n "$added_hotfix" ] && [ "$is_hotfix_context" -ne 1 ]; then
            echo "检测到新增 HOTFIX 记录，但当前不是 hotfix 上下文（分支名未命中 hotfix/hf）。"
            echo "请使用 ADR，或在真正的 hotfix 分支中提交。"
            exit 1
          fi

          if [ -n "$added_adr" ] && [ -z "$touched_adr_index" ]; then
            echo "检测到新增 ADR，但未更新 docs/09-ADR-架构决策/ADR-索引.md"
            exit 1
          fi

      - name: Prevent removing trace fields without ADR/HOTFIX
        shell: bash
        run: |
          set -euo pipefail
          source diff_meta.env

          is_hotfix_context=0
          REF_NAME="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME:-}}"
          if echo "${REF_NAME}" | grep -Eiq "(^|/)(hotfix|hf)(/|$|-)"; then
            is_hotfix_context=1
          fi

          run_git_diff_u0() {
            if [ "${DIFF_MODE}" = "pull_request" ]; then
              # shellcheck disable=SC2086
              git diff -U0 ${DIFF_RANGE} -- "$@"
            else
              if [ "${IS_ROOT}" = "1" ]; then
                git diff -U0 --root "${AFTER_SHA}" -- "$@"
              else
                git diff -U0 "${BEFORE_SHA}" "${AFTER_SHA}" -- "$@"
              fi
            fi
          }

          run_git_diff_u0 \
            ':(glob)modules/**' \
            ':(glob)apps/**' \
            ':(glob)services/**' \
            ':(glob)src/**' \
            > diff_patch.txt || true

          if ! grep -E "^-.*\\b(traceId|workflowInstanceId|stepId)\\b" diff_patch.txt >/dev/null; then
            echo "未检测到可追溯字段删除，跳过。"
            exit 0
          fi

          added_adr=$(grep -E "^A[[:space:]]+docs/09-ADR-架构决策/ADR-[0-9]{8}-.*\.md$" changed_name_status.txt || true)
          added_hotfix=$(grep -E "^A[[:space:]]+docs/09-ADR-架构决策/HOTFIX-[0-9]{8}-.*\.md$" changed_name_status.txt || true)

          if [ -z "$added_adr" ]; then
            if [ "$is_hotfix_context" -eq 1 ] && [ -n "$added_hotfix" ]; then
              echo "检测到可追溯字段删除，但 hotfix 场景已新增 HOTFIX 记录，允许临时通过。"
              exit 0
            fi

            echo "检测到删除可追溯关键字段（traceId/workflowInstanceId/stepId）。"
            echo "禁止直接删除；如确需删除/替换，必须新增 ADR（hotfix 场景可先新增 HOTFIX）。"
            echo "命中示例（最多展示 20 行）："
            grep -E "^-.*\\b(traceId|workflowInstanceId|stepId)\\b" diff_patch.txt | head -n 20
            exit 1
          fi

          echo "检测到可追溯字段删除，但已新增 ADR，允许通过（请在 ADR 中说明原因与替代方案）。"
